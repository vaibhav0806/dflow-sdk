{"version":3,"sources":["../src/utils/http.ts","../src/utils/constants.ts","../src/api/metadata/events.ts","../src/api/metadata/markets.ts","../src/api/metadata/orderbook.ts","../src/api/metadata/trades.ts","../src/api/metadata/liveData.ts","../src/api/metadata/series.ts","../src/api/metadata/tags.ts","../src/api/metadata/sports.ts","../src/api/metadata/search.ts","../src/api/trade/orders.ts","../src/api/trade/swap.ts","../src/api/trade/intent.ts","../src/api/trade/predictionMarket.ts","../src/api/trade/tokens.ts","../src/api/trade/venues.ts","../src/websocket/client.ts","../src/client.ts","../src/solana/transactions.ts","../src/solana/positions.ts","../src/utils/retry.ts","../src/utils/pagination.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Configuration options for the HTTP client.\n */\nexport interface HttpClientOptions {\n  /** Base URL for API requests */\n  baseUrl: string;\n  /** Optional API key for authenticated requests */\n  apiKey?: string;\n  /** Optional additional headers to include in all requests */\n  headers?: Record<string, string>;\n}\n\n/**\n * Custom error class for DFlow API errors.\n *\n * Thrown when the API returns a non-2xx status code.\n * Contains the HTTP status code and response body for debugging.\n *\n * @example\n * ```typescript\n * import { DFlowApiError } from 'dflow-sdk';\n *\n * try {\n *   const market = await dflow.markets.getMarket('invalid-ticker');\n * } catch (error) {\n *   if (error instanceof DFlowApiError) {\n *     console.error(`API Error ${error.statusCode}: ${error.message}`);\n *     console.error('Response:', error.response);\n *   }\n * }\n * ```\n */\nexport class DFlowApiError extends Error {\n  /**\n   * Create a new API error.\n   *\n   * @param message - Error message\n   * @param statusCode - HTTP status code from the response\n   * @param response - Parsed response body (if available)\n   */\n  constructor(\n    message: string,\n    public statusCode: number,\n    public response?: unknown\n  ) {\n    super(message);\n    this.name = 'DFlowApiError';\n  }\n}\n\n/**\n * Internal HTTP client for making API requests.\n *\n * Handles request construction, authentication headers, and response parsing.\n * Used internally by all API classes.\n */\nexport class HttpClient {\n  private baseUrl: string;\n  private apiKey?: string;\n  private defaultHeaders: Record<string, string>;\n\n  /**\n   * Create a new HTTP client.\n   *\n   * @param options - Client configuration\n   */\n  constructor(options: HttpClientOptions) {\n    // Ensure baseUrl ends with /\n    this.baseUrl = options.baseUrl.endsWith('/') ? options.baseUrl : options.baseUrl + '/';\n    this.apiKey = options.apiKey;\n    this.defaultHeaders = {\n      'Content-Type': 'application/json',\n      Accept: 'application/json',\n      ...options.headers,\n    };\n  }\n\n  private getHeaders(): Record<string, string> {\n    const headers = { ...this.defaultHeaders };\n    if (this.apiKey) {\n      headers['x-api-key'] = this.apiKey;\n    }\n    return headers;\n  }\n\n  private buildUrl(path: string, params?: object): string {\n    // Remove leading slash from path to avoid URL resolution issues\n    const cleanPath = path.startsWith('/') ? path.slice(1) : path;\n    const url = new URL(cleanPath, this.baseUrl);\n\n    if (params) {\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          url.searchParams.append(key, String(value));\n        }\n      });\n    }\n\n    return url.toString();\n  }\n\n  /**\n   * Make a GET request.\n   *\n   * @param path - API endpoint path\n   * @param params - Optional query parameters\n   * @returns Parsed JSON response\n   * @throws {@link DFlowApiError} if the request fails\n   */\n  async get<T>(path: string, params?: object): Promise<T> {\n    const url = this.buildUrl(path, params);\n\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: this.getHeaders(),\n    });\n\n    return this.handleResponse<T>(response);\n  }\n\n  /**\n   * Make a POST request.\n   *\n   * @param path - API endpoint path\n   * @param body - Optional request body (will be JSON serialized)\n   * @returns Parsed JSON response\n   * @throws {@link DFlowApiError} if the request fails\n   */\n  async post<T>(path: string, body?: unknown): Promise<T> {\n    const url = this.buildUrl(path);\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: this.getHeaders(),\n      body: body ? JSON.stringify(body) : undefined,\n    });\n\n    return this.handleResponse<T>(response);\n  }\n\n  private async handleResponse<T>(response: Response): Promise<T> {\n    const text = await response.text();\n\n    if (!response.ok) {\n      let errorBody: unknown;\n      try {\n        errorBody = JSON.parse(text);\n      } catch {\n        errorBody = text;\n      }\n\n      throw new DFlowApiError(\n        `HTTP ${response.status}: ${response.statusText}`,\n        response.status,\n        errorBody\n      );\n    }\n\n    try {\n      return JSON.parse(text) as T;\n    } catch {\n      throw new DFlowApiError(\n        `Failed to parse response as JSON`,\n        response.status,\n        text\n      );\n    }\n  }\n\n  /**\n   * Update the API key for subsequent requests.\n   *\n   * @param apiKey - New API key to use\n   */\n  setApiKey(apiKey: string): void {\n    this.apiKey = apiKey;\n  }\n}\n","// ============================================================================\n// API URLs\n// ============================================================================\n\n/**\n * Default metadata API base URL (development environment).\n * No API key required. For testing with real capital against Kalshi.\n */\nexport const METADATA_API_BASE_URL = 'https://dev-prediction-markets-api.dflow.net/api/v1';\n\n/**\n * Default trade API base URL (development environment).\n * No API key required. For testing with real capital against Kalshi.\n */\nexport const TRADE_API_BASE_URL = 'https://dev-quote-api.dflow.net';\n\n/**\n * Default WebSocket URL (development environment).\n * No API key required.\n */\nexport const WEBSOCKET_URL = 'wss://dev-prediction-markets-api.dflow.net/api/v1/ws';\n\n/**\n * Production metadata API base URL.\n * Requires API key for access.\n */\nexport const PROD_METADATA_API_BASE_URL = 'https://prediction-markets-api.dflow.net/api/v1';\n\n/**\n * Production trade API base URL.\n * Requires API key for access.\n */\nexport const PROD_TRADE_API_BASE_URL = 'https://quote-api.dflow.net';\n\n/**\n * Production WebSocket URL.\n * Requires API key for access.\n */\nexport const PROD_WEBSOCKET_URL = 'wss://prediction-markets-api.dflow.net/api/v1/ws';\n\n// ============================================================================\n// Token Mints\n// ============================================================================\n\n/**\n * USDC token mint address on Solana mainnet.\n * Used as the default settlement currency for prediction markets.\n */\nexport const USDC_MINT = 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v';\n\n/**\n * Native SOL mint address (wrapped SOL).\n */\nexport const SOL_MINT = 'So11111111111111111111111111111111111111112';\n\n// ============================================================================\n// Trading Defaults\n// ============================================================================\n\n/**\n * Default slippage tolerance in basis points (0.5%).\n * 50 bps = 0.5% = multiply price by 1.005 for max acceptable price.\n */\nexport const DEFAULT_SLIPPAGE_BPS = 50;\n\n/**\n * Number of decimal places for outcome tokens.\n * All YES/NO tokens use 6 decimals (same as USDC).\n */\nexport const OUTCOME_TOKEN_DECIMALS = 6;\n\n// ============================================================================\n// API Limits\n// ============================================================================\n\n/**\n * Maximum number of items in a batch request.\n * Applies to getMarketsBatch and similar batch endpoints.\n */\nexport const MAX_BATCH_SIZE = 100;\n\n/**\n * Maximum number of addresses for filterOutcomeMints.\n */\nexport const MAX_FILTER_ADDRESSES = 200;\n","import type { HttpClient } from '../../utils/http.js';\nimport type {\n  Event,\n  EventsParams,\n  EventsResponse,\n  ForecastHistory,\n  Candlestick,\n} from '../../types/index.js';\n\n/**\n * API for discovering and querying prediction market events.\n *\n * Events are the top-level containers for prediction markets. Each event\n * represents a question or outcome to predict (e.g., \"Will Bitcoin exceed $100k?\")\n * and contains one or more markets for trading.\n *\n * @example\n * ```typescript\n * const dflow = new DFlowClient();\n *\n * // Get active events\n * const { events } = await dflow.events.getEvents({ status: 'active' });\n *\n * // Get a specific event with its markets\n * const event = await dflow.events.getEvent('event-id', true);\n * ```\n */\nexport class EventsAPI {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Get a single event by its ID.\n   *\n   * @param eventId - The unique identifier of the event\n   * @param withNestedMarkets - If true, includes all markets within the event\n   * @returns The event data, optionally with nested markets\n   *\n   * @example\n   * ```typescript\n   * // Get event without markets\n   * const event = await dflow.events.getEvent('BTCD-25DEC0313');\n   *\n   * // Get event with all its markets\n   * const eventWithMarkets = await dflow.events.getEvent('BTCD-25DEC0313', true);\n   * console.log(eventWithMarkets.markets); // Array of Market objects\n   * ```\n   */\n  async getEvent(eventId: string, withNestedMarkets?: boolean): Promise<Event> {\n    return this.http.get<Event>(`/event/${eventId}`, {\n      withNestedMarkets,\n    });\n  }\n\n  /**\n   * List events with optional filtering.\n   *\n   * @param params - Optional filter parameters\n   * @param params.status - Filter by event status ('active', 'closed', etc.)\n   * @param params.seriesTicker - Filter by series ticker (e.g., 'KXBTC')\n   * @param params.limit - Maximum number of events to return\n   * @param params.cursor - Pagination cursor from previous response\n   * @returns Paginated list of events\n   *\n   * @example\n   * ```typescript\n   * // Get all active events\n   * const { events, cursor } = await dflow.events.getEvents({ status: 'active' });\n   *\n   * // Get events for a specific series\n   * const btcEvents = await dflow.events.getEvents({\n   *   seriesTicker: 'KXBTC',\n   *   limit: 50,\n   * });\n   *\n   * // Paginate through results\n   * const nextPage = await dflow.events.getEvents({ cursor });\n   * ```\n   */\n  async getEvents(params?: EventsParams): Promise<EventsResponse> {\n    return this.http.get<EventsResponse>('/events', params);\n  }\n\n  /**\n   * Get forecast percentile history for an event.\n   *\n   * Returns historical forecast data showing how predictions have changed over time.\n   *\n   * @param seriesTicker - The series ticker (e.g., 'KXBTC')\n   * @param eventId - The event identifier within the series\n   * @returns Forecast history with percentile data points\n   *\n   * @example\n   * ```typescript\n   * const history = await dflow.events.getEventForecastHistory('KXBTC', 'event-123');\n   * console.log(history.dataPoints); // Historical forecast values\n   * ```\n   */\n  async getEventForecastHistory(\n    seriesTicker: string,\n    eventId: string\n  ): Promise<ForecastHistory> {\n    return this.http.get<ForecastHistory>(\n      `/event/${seriesTicker}/${eventId}/forecast_percentile_history`\n    );\n  }\n\n  /**\n   * Get forecast percentile history for an event by its mint address.\n   *\n   * Alternative to {@link getEventForecastHistory} when you have the mint address\n   * instead of series ticker and event ID.\n   *\n   * @param mintAddress - The Solana mint address of the event's outcome token\n   * @returns Forecast history with percentile data points\n   *\n   * @example\n   * ```typescript\n   * const history = await dflow.events.getEventForecastByMint('EPjFWdd5...');\n   * ```\n   */\n  async getEventForecastByMint(mintAddress: string): Promise<ForecastHistory> {\n    return this.http.get<ForecastHistory>(\n      `/event/by-mint/${mintAddress}/forecast_percentile_history`\n    );\n  }\n\n  /**\n   * Get OHLCV candlestick data for an event.\n   *\n   * Returns price history in candlestick format for charting.\n   *\n   * @param ticker - The event ticker\n   * @returns Array of candlestick data points\n   *\n   * @example\n   * ```typescript\n   * const candles = await dflow.events.getEventCandlesticks('BTCD-25DEC0313');\n   * candles.forEach(c => {\n   *   console.log(`Open: ${c.open}, High: ${c.high}, Low: ${c.low}, Close: ${c.close}`);\n   * });\n   * ```\n   */\n  async getEventCandlesticks(ticker: string): Promise<Candlestick[]> {\n    const response = await this.http.get<{ candlesticks: Candlestick[] }>(\n      `/event/${ticker}/candlesticks`\n    );\n    return response.candlesticks;\n  }\n}\n","import type { HttpClient } from '../../utils/http.js';\nimport type {\n  Market,\n  MarketsParams,\n  MarketsResponse,\n  MarketsBatchParams,\n  MarketsBatchResponse,\n  FilterOutcomeMintsParams,\n  FilterOutcomeMintsResponse,\n  Candlestick,\n} from '../../types/index.js';\nimport { MAX_BATCH_SIZE, MAX_FILTER_ADDRESSES } from '../../utils/constants.js';\n\n/**\n * API for querying prediction market data, pricing, and batch operations.\n *\n * Markets represent individual trading instruments within events. Each market\n * has YES and NO outcome tokens that can be traded. Markets can be binary\n * (yes/no) or scalar (range of values).\n *\n * @example\n * ```typescript\n * const dflow = new DFlowClient();\n *\n * // Get a specific market\n * const market = await dflow.markets.getMarket('BTCD-25DEC0313-T92749.99');\n *\n * // Get active markets\n * const { markets } = await dflow.markets.getMarkets({ status: 'active' });\n *\n * // Batch query multiple markets\n * const markets = await dflow.markets.getMarketsBatch({\n *   tickers: ['MARKET-1', 'MARKET-2'],\n * });\n * ```\n */\nexport class MarketsAPI {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Get a single market by its ticker.\n   *\n   * @param marketId - The market ticker (e.g., 'BTCD-25DEC0313-T92749.99')\n   * @returns Complete market data including prices, accounts, and status\n   *\n   * @example\n   * ```typescript\n   * const market = await dflow.markets.getMarket('BTCD-25DEC0313-T92749.99');\n   * console.log(`YES: ${market.yesAsk}, NO: ${market.noAsk}`);\n   * console.log(`Volume: ${market.volume}`);\n   * ```\n   */\n  async getMarket(marketId: string): Promise<Market> {\n    return this.http.get<Market>(`/market/${marketId}`);\n  }\n\n  /**\n   * Get a market by its outcome token mint address.\n   *\n   * Useful when you have a mint address from a wallet or transaction\n   * and need to look up the associated market.\n   *\n   * @param mintAddress - The Solana mint address of a YES or NO token\n   * @returns The market associated with the mint address\n   *\n   * @example\n   * ```typescript\n   * const market = await dflow.markets.getMarketByMint('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');\n   * ```\n   */\n  async getMarketByMint(mintAddress: string): Promise<Market> {\n    return this.http.get<Market>(`/market/by-mint/${mintAddress}`);\n  }\n\n  /**\n   * List markets with optional filtering.\n   *\n   * @param params - Optional filter parameters\n   * @param params.status - Filter by market status ('active', 'closed', etc.)\n   * @param params.eventTicker - Filter by parent event ticker\n   * @param params.limit - Maximum number of markets to return\n   * @param params.cursor - Pagination cursor from previous response\n   * @returns Paginated list of markets\n   *\n   * @example\n   * ```typescript\n   * // Get all active markets\n   * const { markets, cursor } = await dflow.markets.getMarkets({ status: 'active' });\n   *\n   * // Get markets for a specific event\n   * const eventMarkets = await dflow.markets.getMarkets({\n   *   eventTicker: 'BTCD-25DEC0313',\n   * });\n   *\n   * // Paginate through results\n   * const nextPage = await dflow.markets.getMarkets({ cursor });\n   * ```\n   */\n  async getMarkets(params?: MarketsParams): Promise<MarketsResponse> {\n    return this.http.get<MarketsResponse>('/markets', params);\n  }\n\n  /**\n   * Batch query multiple markets by tickers and/or mint addresses.\n   *\n   * More efficient than multiple individual requests when you need\n   * data for several markets at once.\n   *\n   * @param params - Batch query parameters\n   * @param params.tickers - Array of market tickers to fetch\n   * @param params.mints - Array of mint addresses to fetch\n   * @returns Array of market data\n   * @throws Error if total items exceed {@link MAX_BATCH_SIZE} (100)\n   *\n   * @example\n   * ```typescript\n   * const markets = await dflow.markets.getMarketsBatch({\n   *   tickers: ['MARKET-1', 'MARKET-2', 'MARKET-3'],\n   *   mints: ['mint-address-1'],\n   * });\n   * ```\n   */\n  async getMarketsBatch(params: MarketsBatchParams): Promise<Market[]> {\n    const totalItems = (params.tickers?.length ?? 0) + (params.mints?.length ?? 0);\n    if (totalItems > MAX_BATCH_SIZE) {\n      throw new Error(`Batch size exceeds maximum of ${MAX_BATCH_SIZE} items`);\n    }\n\n    const response = await this.http.post<MarketsBatchResponse>('/markets/batch', params);\n    return response.markets;\n  }\n\n  /**\n   * Get all outcome token mint addresses.\n   *\n   * Returns a list of all valid outcome token mints across all markets.\n   * Useful for filtering wallet tokens to find prediction market positions.\n   *\n   * @returns Array of mint addresses\n   *\n   * @example\n   * ```typescript\n   * const allMints = await dflow.markets.getOutcomeMints();\n   * console.log(`Total outcome tokens: ${allMints.length}`);\n   * ```\n   */\n  async getOutcomeMints(): Promise<string[]> {\n    const response = await this.http.get<{ mints: string[] }>('/outcome_mints');\n    return response.mints;\n  }\n\n  /**\n   * Filter a list of addresses to find which are outcome token mints.\n   *\n   * Given a list of token addresses (e.g., from a wallet), returns only\n   * those that are prediction market outcome tokens.\n   *\n   * @param addresses - Array of Solana token addresses to check\n   * @returns Array of addresses that are outcome token mints\n   * @throws Error if addresses exceed {@link MAX_FILTER_ADDRESSES} (200)\n   *\n   * @example\n   * ```typescript\n   * // Get user's wallet tokens\n   * const walletTokens = ['addr1', 'addr2', 'addr3', ...];\n   *\n   * // Filter to find prediction market tokens\n   * const predictionTokens = await dflow.markets.filterOutcomeMints(walletTokens);\n   * ```\n   */\n  async filterOutcomeMints(addresses: string[]): Promise<string[]> {\n    if (addresses.length > MAX_FILTER_ADDRESSES) {\n      throw new Error(`Address count exceeds maximum of ${MAX_FILTER_ADDRESSES}`);\n    }\n\n    const params: FilterOutcomeMintsParams = { addresses };\n    const response = await this.http.post<FilterOutcomeMintsResponse>(\n      '/filter_outcome_mints',\n      params\n    );\n    return response.outcomeMints;\n  }\n\n  /**\n   * Get OHLCV candlestick data for a market.\n   *\n   * Returns price history in candlestick format for charting.\n   *\n   * @param ticker - The market ticker\n   * @returns Array of candlestick data points\n   *\n   * @example\n   * ```typescript\n   * const candles = await dflow.markets.getMarketCandlesticks('BTCD-25DEC0313-T92749.99');\n   * candles.forEach(c => {\n   *   console.log(`${c.timestamp}: O=${c.open} H=${c.high} L=${c.low} C=${c.close}`);\n   * });\n   * ```\n   */\n  async getMarketCandlesticks(ticker: string): Promise<Candlestick[]> {\n    const response = await this.http.get<{ candlesticks: Candlestick[] }>(\n      `/market/${ticker}/candlesticks`\n    );\n    return response.candlesticks;\n  }\n\n  /**\n   * Get OHLCV candlestick data for a market by mint address.\n   *\n   * Alternative to {@link getMarketCandlesticks} when you have the mint address.\n   *\n   * @param mintAddress - The Solana mint address of the market's outcome token\n   * @returns Array of candlestick data points\n   *\n   * @example\n   * ```typescript\n   * const candles = await dflow.markets.getMarketCandlesticksByMint('EPjFWdd5...');\n   * ```\n   */\n  async getMarketCandlesticksByMint(mintAddress: string): Promise<Candlestick[]> {\n    const response = await this.http.get<{ candlesticks: Candlestick[] }>(\n      `/market/by-mint/${mintAddress}/candlesticks`\n    );\n    return response.candlesticks;\n  }\n}\n","import type { HttpClient } from '../../utils/http.js';\nimport type { Orderbook } from '../../types/index.js';\n\n/**\n * API for retrieving orderbook snapshots.\n *\n * The orderbook shows current bid/ask prices and quantities for YES and NO\n * outcome tokens in a market.\n *\n * @example\n * ```typescript\n * const dflow = new DFlowClient();\n *\n * const orderbook = await dflow.orderbook.getOrderbook('BTCD-25DEC0313-T92749.99');\n * console.log(`YES Bid: ${orderbook.yesBid.price}, Ask: ${orderbook.yesAsk.price}`);\n * ```\n */\nexport class OrderbookAPI {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Get the orderbook for a market by ticker.\n   *\n   * @param marketTicker - The market ticker\n   * @returns Orderbook with YES/NO bid and ask prices and quantities\n   *\n   * @example\n   * ```typescript\n   * const orderbook = await dflow.orderbook.getOrderbook('BTCD-25DEC0313-T92749.99');\n   * console.log(`YES: Bid ${orderbook.yesBid.price} / Ask ${orderbook.yesAsk.price}`);\n   * console.log(`NO:  Bid ${orderbook.noBid.price} / Ask ${orderbook.noAsk.price}`);\n   * ```\n   */\n  async getOrderbook(marketTicker: string): Promise<Orderbook> {\n    return this.http.get<Orderbook>(`/orderbook/${marketTicker}`);\n  }\n\n  /**\n   * Get the orderbook for a market by mint address.\n   *\n   * Alternative to {@link getOrderbook} when you have the mint address.\n   *\n   * @param mintAddress - The Solana mint address of the market's outcome token\n   * @returns Orderbook with YES/NO bid and ask prices and quantities\n   *\n   * @example\n   * ```typescript\n   * const orderbook = await dflow.orderbook.getOrderbookByMint('EPjFWdd5...');\n   * ```\n   */\n  async getOrderbookByMint(mintAddress: string): Promise<Orderbook> {\n    return this.http.get<Orderbook>(`/orderbook/by-mint/${mintAddress}`);\n  }\n}\n","import type { HttpClient } from '../../utils/http.js';\nimport type { TradesParams, TradesResponse } from '../../types/index.js';\n\n/**\n * API for retrieving historical trade data.\n *\n * Access past trades for markets to analyze trading activity and price history.\n *\n * @example\n * ```typescript\n * const dflow = new DFlowClient();\n *\n * const { trades } = await dflow.trades.getTrades({\n *   marketTicker: 'BTCD-25DEC0313-T92749.99',\n *   limit: 100,\n * });\n * ```\n */\nexport class TradesAPI {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Get historical trades with optional filtering.\n   *\n   * @param params - Optional filter parameters\n   * @param params.marketTicker - Filter by market ticker\n   * @param params.limit - Maximum number of trades to return\n   * @param params.cursor - Pagination cursor from previous response\n   * @returns Paginated list of trades\n   *\n   * @example\n   * ```typescript\n   * // Get recent trades for a market\n   * const { trades, cursor } = await dflow.trades.getTrades({\n   *   marketTicker: 'BTCD-25DEC0313-T92749.99',\n   *   limit: 100,\n   * });\n   *\n   * // Paginate through results\n   * const nextPage = await dflow.trades.getTrades({ cursor });\n   * ```\n   */\n  async getTrades(params?: TradesParams): Promise<TradesResponse> {\n    return this.http.get<TradesResponse>('/trades', params);\n  }\n\n  /**\n   * Get trades for a market by mint address.\n   *\n   * Alternative to {@link getTrades} when you have the mint address.\n   *\n   * @param mintAddress - The Solana mint address of the market's outcome token\n   * @param params - Optional filter parameters (excluding marketTicker)\n   * @returns Paginated list of trades\n   *\n   * @example\n   * ```typescript\n   * const { trades } = await dflow.trades.getTradesByMint('EPjFWdd5...', {\n   *   limit: 50,\n   * });\n   * ```\n   */\n  async getTradesByMint(\n    mintAddress: string,\n    params?: Omit<TradesParams, 'marketTicker'>\n  ): Promise<TradesResponse> {\n    return this.http.get<TradesResponse>(`/trades/by-mint/${mintAddress}`, params);\n  }\n}\n","import type { HttpClient } from '../../utils/http.js';\nimport type { LiveData, LiveDataResponse } from '../../types/index.js';\n\n/**\n * API for retrieving real-time milestone and progress data.\n *\n * Live data provides real-time updates on event milestones and progress\n * indicators that can affect market outcomes.\n *\n * @example\n * ```typescript\n * const dflow = new DFlowClient();\n *\n * // Get live data for specific milestones\n * const data = await dflow.liveData.getLiveData(['milestone1', 'milestone2']);\n *\n * // Get live data for an event\n * const eventData = await dflow.liveData.getLiveDataByEvent('BTCD-25DEC0313');\n * ```\n */\nexport class LiveDataAPI {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Get live data for specific milestones.\n   *\n   * @param milestones - Array of milestone identifiers to fetch\n   * @returns Array of live data for the requested milestones\n   *\n   * @example\n   * ```typescript\n   * const data = await dflow.liveData.getLiveData(['btc-price', 'eth-price']);\n   * data.forEach(d => console.log(`${d.milestone}: ${d.value}`));\n   * ```\n   */\n  async getLiveData(milestones: string[]): Promise<LiveData[]> {\n    const response = await this.http.get<LiveDataResponse>('/live_data', {\n      milestones: milestones.join(','),\n    });\n    return response.data;\n  }\n\n  /**\n   * Get live data for an event by its ticker.\n   *\n   * @param eventTicker - The event ticker\n   * @returns Live data for the event\n   *\n   * @example\n   * ```typescript\n   * const data = await dflow.liveData.getLiveDataByEvent('BTCD-25DEC0313');\n   * console.log(`Current value: ${data.value}`);\n   * ```\n   */\n  async getLiveDataByEvent(eventTicker: string): Promise<LiveData> {\n    return this.http.get<LiveData>(`/live_data/by-event/${eventTicker}`);\n  }\n\n  /**\n   * Get live data for a market by mint address.\n   *\n   * @param mintAddress - The Solana mint address of the market's outcome token\n   * @returns Live data for the market\n   *\n   * @example\n   * ```typescript\n   * const data = await dflow.liveData.getLiveDataByMint('EPjFWdd5...');\n   * ```\n   */\n  async getLiveDataByMint(mintAddress: string): Promise<LiveData> {\n    return this.http.get<LiveData>(`/live_data/by-mint/${mintAddress}`);\n  }\n}\n","import type { HttpClient } from '../../utils/http.js';\nimport type { Series, SeriesResponse } from '../../types/index.js';\n\n/**\n * API for retrieving series/category information.\n *\n * Series group related events together (e.g., all Bitcoin price events,\n * all election events). Use series to browse events by category.\n *\n * @example\n * ```typescript\n * const dflow = new DFlowClient();\n *\n * // Get all series\n * const series = await dflow.series.getSeries();\n *\n * // Get a specific series\n * const btcSeries = await dflow.series.getSeriesByTicker('KXBTC');\n * ```\n */\nexport class SeriesAPI {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Get all available series.\n   *\n   * @returns Array of all series\n   *\n   * @example\n   * ```typescript\n   * const series = await dflow.series.getSeries();\n   * series.forEach(s => console.log(`${s.ticker}: ${s.name}`));\n   * ```\n   */\n  async getSeries(): Promise<Series[]> {\n    const response = await this.http.get<SeriesResponse>('/series');\n    return response.series;\n  }\n\n  /**\n   * Get a specific series by its ticker.\n   *\n   * @param ticker - The series ticker (e.g., 'KXBTC', 'KXETH')\n   * @returns The series data\n   *\n   * @example\n   * ```typescript\n   * const series = await dflow.series.getSeriesByTicker('KXBTC');\n   * console.log(`${series.name}: ${series.description}`);\n   * ```\n   */\n  async getSeriesByTicker(ticker: string): Promise<Series> {\n    return this.http.get<Series>(`/series/${ticker}`);\n  }\n}\n","import type { HttpClient } from '../../utils/http.js';\nimport type { CategoryTags } from '../../types/index.js';\n\n/**\n * API for retrieving category tags.\n *\n * Tags provide a way to categorize and filter events by topic\n * (e.g., 'crypto', 'politics', 'sports').\n *\n * @example\n * ```typescript\n * const dflow = new DFlowClient();\n *\n * const tags = await dflow.tags.getTagsByCategories();\n * console.log(tags.categories);\n * ```\n */\nexport class TagsAPI {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Get all tags organized by category.\n   *\n   * @returns Tags grouped by their categories\n   *\n   * @example\n   * ```typescript\n   * const tags = await dflow.tags.getTagsByCategories();\n   * Object.entries(tags).forEach(([category, tagList]) => {\n   *   console.log(`${category}: ${tagList.join(', ')}`);\n   * });\n   * ```\n   */\n  async getTagsByCategories(): Promise<CategoryTags> {\n    return this.http.get<CategoryTags>('/tags_by_categories');\n  }\n}\n","import type { HttpClient } from '../../utils/http.js';\nimport type { SportsFilters } from '../../types/index.js';\n\n/**\n * API for retrieving sports-specific filters.\n *\n * Get available filters for sports-related prediction markets\n * (leagues, teams, event types, etc.).\n *\n * @example\n * ```typescript\n * const dflow = new DFlowClient();\n *\n * const filters = await dflow.sports.getFiltersBySports();\n * console.log(filters.leagues);\n * ```\n */\nexport class SportsAPI {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Get all available sports filters.\n   *\n   * @returns Sports filters including leagues, teams, and event types\n   *\n   * @example\n   * ```typescript\n   * const filters = await dflow.sports.getFiltersBySports();\n   * filters.leagues.forEach(league => console.log(league.name));\n   * ```\n   */\n  async getFiltersBySports(): Promise<SportsFilters> {\n    return this.http.get<SportsFilters>('/filters_by_sports');\n  }\n}\n","import type { HttpClient } from '../../utils/http.js';\nimport type { SearchParams, SearchResult } from '../../types/index.js';\n\n/**\n * API for searching events and markets.\n *\n * Full-text search across events and markets by keywords.\n *\n * @example\n * ```typescript\n * const dflow = new DFlowClient();\n *\n * const results = await dflow.search.search({ query: 'bitcoin' });\n * console.log(`Found ${results.events.length} events`);\n * ```\n */\nexport class SearchAPI {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Search for events and markets by keyword.\n   *\n   * @param params - Search parameters\n   * @param params.query - The search query string\n   * @param params.limit - Maximum number of results to return\n   * @returns Search results containing matching events and markets\n   *\n   * @example\n   * ```typescript\n   * // Search for Bitcoin-related markets\n   * const results = await dflow.search.search({ query: 'bitcoin', limit: 20 });\n   *\n   * results.events.forEach(event => {\n   *   console.log(`Event: ${event.title}`);\n   * });\n   *\n   * results.markets.forEach(market => {\n   *   console.log(`Market: ${market.title}`);\n   * });\n   * ```\n   */\n  async search(params: SearchParams): Promise<SearchResult> {\n    return this.http.get<SearchResult>('/search', {\n      q: params.query,\n      limit: params.limit,\n    });\n  }\n}\n","import type { HttpClient } from '../../utils/http.js';\nimport type {\n  OrderParams,\n  OrderResponse,\n  OrderStatusResponse,\n} from '../../types/index.js';\n\n/**\n * API for creating and tracking orders.\n *\n * Orders provide a way to get a quote and transaction for trading\n * prediction market outcome tokens. Use this for straightforward\n * order execution.\n *\n * @example\n * ```typescript\n * const dflow = new DFlowClient({ environment: 'production', apiKey: 'your-key' });\n *\n * // Get an order quote and transaction\n * const order = await dflow.orders.getOrder({\n *   inputMint: USDC_MINT,\n *   outputMint: market.accounts.usdc.yesMint,\n *   amount: 1000000, // 1 USDC\n *   slippageBps: 50,\n *   userPublicKey: wallet.publicKey.toBase58(),\n * });\n *\n * // Sign and send the transaction\n * const signature = await signAndSendTransaction(connection, order.transaction, keypair);\n *\n * // Check order status\n * const status = await dflow.orders.getOrderStatus(signature);\n * ```\n */\nexport class OrdersAPI {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Get an order quote and transaction for a trade.\n   *\n   * Returns a ready-to-sign transaction for swapping tokens.\n   *\n   * @param params - Order parameters\n   * @param params.inputMint - The mint address of the token to sell (e.g., USDC)\n   * @param params.outputMint - The mint address of the token to buy (e.g., YES token)\n   * @param params.amount - The amount to trade in base units (e.g., 1000000 for 1 USDC)\n   * @param params.slippageBps - Maximum slippage in basis points (e.g., 50 = 0.5%)\n   * @param params.userPublicKey - The user's Solana wallet public key\n   * @param params.platformFeeBps - Optional platform fee in basis points\n   * @param params.platformFeeAccount - Optional account to receive platform fees\n   * @returns Order response with transaction and quote details\n   *\n   * @example\n   * ```typescript\n   * import { USDC_MINT } from 'dflow-sdk';\n   *\n   * const order = await dflow.orders.getOrder({\n   *   inputMint: USDC_MINT,\n   *   outputMint: market.accounts.usdc.yesMint,\n   *   amount: 1000000, // 1 USDC (6 decimals)\n   *   slippageBps: 50, // 0.5% slippage\n   *   userPublicKey: wallet.publicKey.toBase58(),\n   * });\n   *\n   * console.log(`Input: ${order.inAmount}, Output: ${order.outAmount}`);\n   * // Sign and send order.transaction\n   * ```\n   */\n  async getOrder(params: OrderParams): Promise<OrderResponse> {\n    return this.http.get<OrderResponse>('/order', {\n      inputMint: params.inputMint,\n      outputMint: params.outputMint,\n      amount: String(params.amount),\n      slippageBps: params.slippageBps,\n      userPublicKey: params.userPublicKey,\n      platformFeeBps: params.platformFeeBps,\n      platformFeeAccount: params.platformFeeAccount,\n    });\n  }\n\n  /**\n   * Check the status of a submitted order.\n   *\n   * Use this to track async order completion or check if an order\n   * was successfully executed.\n   *\n   * @param signature - The transaction signature from submitting the order\n   * @returns Order status ('open', 'closed', 'failed', or 'pendingClose')\n   *\n   * @example\n   * ```typescript\n   * const status = await dflow.orders.getOrderStatus(signature);\n   *\n   * if (status.status === 'closed') {\n   *   console.log('Order completed successfully!');\n   * } else if (status.status === 'failed') {\n   *   console.log('Order failed');\n   * } else {\n   *   console.log('Order still pending...');\n   * }\n   * ```\n   */\n  async getOrderStatus(signature: string): Promise<OrderStatusResponse> {\n    return this.http.get<OrderStatusResponse>('/order-status', { signature });\n  }\n}\n","import type { HttpClient } from '../../utils/http.js';\nimport type {\n  QuoteParams,\n  SwapQuote,\n  SwapParams,\n  SwapResponse,\n  SwapInstructionsResponse,\n} from '../../types/index.js';\n\n/**\n * API for imperative swap operations with route preview.\n *\n * The Swap API provides a two-step process: first get a quote to preview\n * the trade, then create a swap transaction. This gives you control over\n * trade execution and allows displaying quotes to users before committing.\n *\n * @example\n * ```typescript\n * const dflow = new DFlowClient();\n *\n * // Step 1: Get a quote\n * const quote = await dflow.swap.getQuote({\n *   inputMint: USDC_MINT,\n *   outputMint: yesMint,\n *   amount: 1000000,\n * });\n * console.log(`You'll receive: ${quote.outAmount} tokens`);\n *\n * // Step 2: Create and execute swap\n * const swap = await dflow.swap.createSwap({\n *   inputMint: USDC_MINT,\n *   outputMint: yesMint,\n *   amount: 1000000,\n *   slippageBps: 50,\n *   userPublicKey: wallet.publicKey.toBase58(),\n * });\n * ```\n */\nexport class SwapAPI {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Get a quote for a swap without creating a transaction.\n   *\n   * Use this to preview trade amounts before committing. The quote\n   * shows expected input/output amounts and price impact.\n   *\n   * @param params - Quote parameters\n   * @param params.inputMint - The mint address of the token to sell\n   * @param params.outputMint - The mint address of the token to buy\n   * @param params.amount - The amount to trade in base units\n   * @param params.slippageBps - Optional slippage tolerance in basis points\n   * @returns Quote with expected amounts and route information\n   *\n   * @example\n   * ```typescript\n   * const quote = await dflow.swap.getQuote({\n   *   inputMint: USDC_MINT,\n   *   outputMint: market.accounts.usdc.yesMint,\n   *   amount: 1000000, // 1 USDC\n   *   slippageBps: 50,\n   * });\n   *\n   * console.log(`Input: ${quote.inAmount}`);\n   * console.log(`Output: ${quote.outAmount}`);\n   * console.log(`Price impact: ${quote.priceImpactPct}%`);\n   * ```\n   */\n  async getQuote(params: QuoteParams): Promise<SwapQuote> {\n    return this.http.get<SwapQuote>('/quote', {\n      inputMint: params.inputMint,\n      outputMint: params.outputMint,\n      amount: String(params.amount),\n      slippageBps: params.slippageBps,\n    });\n  }\n\n  /**\n   * Create a swap transaction ready for signing.\n   *\n   * Combines getting a quote and creating a transaction in one call.\n   * Returns a base64-encoded transaction that can be signed and sent.\n   *\n   * @param params - Swap parameters\n   * @param params.inputMint - The mint address of the token to sell\n   * @param params.outputMint - The mint address of the token to buy\n   * @param params.amount - The amount to trade in base units\n   * @param params.slippageBps - Slippage tolerance in basis points\n   * @param params.userPublicKey - The user's Solana wallet public key\n   * @param params.wrapUnwrapSol - Whether to wrap/unwrap SOL automatically\n   * @param params.priorityFee - Optional priority fee configuration\n   * @returns Swap response with transaction and quote details\n   *\n   * @example\n   * ```typescript\n   * const swap = await dflow.swap.createSwap({\n   *   inputMint: USDC_MINT,\n   *   outputMint: market.accounts.usdc.yesMint,\n   *   amount: 1000000,\n   *   slippageBps: 50,\n   *   userPublicKey: wallet.publicKey.toBase58(),\n   *   wrapUnwrapSol: true,\n   *   priorityFee: { type: 'exact', amount: 10000 },\n   * });\n   *\n   * // Sign and send the transaction\n   * const result = await signSendAndConfirm(connection, swap.transaction, keypair);\n   * ```\n   */\n  async createSwap(params: SwapParams): Promise<SwapResponse> {\n    // First get a quote\n    const quoteResponse = await this.getQuote({\n      inputMint: params.inputMint,\n      outputMint: params.outputMint,\n      amount: params.amount,\n      slippageBps: params.slippageBps,\n    });\n\n    // Then create the swap with the quote response\n    return this.http.post<SwapResponse>('/swap', {\n      quoteResponse,\n      userPublicKey: params.userPublicKey,\n      wrapUnwrapSol: params.wrapUnwrapSol,\n      priorityFee: params.priorityFee,\n    });\n  }\n\n  /**\n   * Get swap instructions for custom transaction composition.\n   *\n   * Instead of a complete transaction, returns individual instructions\n   * that can be combined with other instructions in a custom transaction.\n   * Useful for advanced use cases like atomic multi-step operations.\n   *\n   * @param params - Swap parameters (same as {@link createSwap})\n   * @returns Instructions and accounts for building a custom transaction\n   *\n   * @example\n   * ```typescript\n   * const instructions = await dflow.swap.getSwapInstructions({\n   *   inputMint: USDC_MINT,\n   *   outputMint: yesMint,\n   *   amount: 1000000,\n   *   slippageBps: 50,\n   *   userPublicKey: wallet.publicKey.toBase58(),\n   * });\n   *\n   * // Build a custom transaction with these instructions\n   * const tx = new Transaction();\n   * instructions.instructions.forEach(ix => tx.add(ix));\n   * ```\n   */\n  async getSwapInstructions(params: SwapParams): Promise<SwapInstructionsResponse> {\n    // First get a quote\n    const quoteResponse = await this.getQuote({\n      inputMint: params.inputMint,\n      outputMint: params.outputMint,\n      amount: params.amount,\n      slippageBps: params.slippageBps,\n    });\n\n    // Then get instructions with the quote response\n    return this.http.post<SwapInstructionsResponse>('/swap-instructions', {\n      quoteResponse,\n      userPublicKey: params.userPublicKey,\n      wrapUnwrapSol: params.wrapUnwrapSol,\n      priorityFee: params.priorityFee,\n    });\n  }\n}\n","import type { HttpClient } from '../../utils/http.js';\nimport type {\n  IntentQuoteParams,\n  IntentQuote,\n  SubmitIntentParams,\n  IntentResponse,\n} from '../../types/index.js';\n\n/**\n * API for declarative intent-based swaps.\n *\n * Intents provide a declarative approach to trading where you specify\n * what you want (exact input or exact output) and the system handles\n * the execution details. This is useful for \"sell exactly X\" or\n * \"buy exactly Y\" scenarios.\n *\n * @example\n * ```typescript\n * const dflow = new DFlowClient();\n *\n * // ExactIn: Sell exactly 1 USDC, receive variable YES tokens\n * const intent = await dflow.intent.submitIntent({\n *   inputMint: USDC_MINT,\n *   outputMint: yesMint,\n *   amount: 1000000,\n *   mode: 'ExactIn',\n *   slippageBps: 50,\n *   userPublicKey: wallet.publicKey.toBase58(),\n * });\n *\n * // ExactOut: Receive exactly 100 YES tokens, pay variable USDC\n * const intent = await dflow.intent.submitIntent({\n *   inputMint: USDC_MINT,\n *   outputMint: yesMint,\n *   amount: 100000000, // 100 tokens\n *   mode: 'ExactOut',\n *   slippageBps: 50,\n *   userPublicKey: wallet.publicKey.toBase58(),\n * });\n * ```\n */\nexport class IntentAPI {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Get a quote for an intent-based swap.\n   *\n   * Preview what you'll receive (ExactIn) or what you'll pay (ExactOut)\n   * before submitting the intent.\n   *\n   * @param params - Intent quote parameters\n   * @param params.inputMint - The mint address of the token to sell\n   * @param params.outputMint - The mint address of the token to buy\n   * @param params.amount - The exact amount (input or output based on mode)\n   * @param params.mode - 'ExactIn' to specify input amount, 'ExactOut' for output amount\n   * @returns Quote showing expected amounts\n   *\n   * @example\n   * ```typescript\n   * // How much YES will I get for exactly 1 USDC?\n   * const quote = await dflow.intent.getIntentQuote({\n   *   inputMint: USDC_MINT,\n   *   outputMint: yesMint,\n   *   amount: 1000000,\n   *   mode: 'ExactIn',\n   * });\n   * console.log(`You'll receive: ${quote.outAmount} YES tokens`);\n   *\n   * // How much USDC do I need to get exactly 100 YES tokens?\n   * const quote = await dflow.intent.getIntentQuote({\n   *   inputMint: USDC_MINT,\n   *   outputMint: yesMint,\n   *   amount: 100000000,\n   *   mode: 'ExactOut',\n   * });\n   * console.log(`You'll pay: ${quote.inAmount} USDC`);\n   * ```\n   */\n  async getIntentQuote(params: IntentQuoteParams): Promise<IntentQuote> {\n    return this.http.get<IntentQuote>('/intent', {\n      inputMint: params.inputMint,\n      outputMint: params.outputMint,\n      amount: String(params.amount),\n      mode: params.mode,\n    });\n  }\n\n  /**\n   * Submit an intent-based swap for execution.\n   *\n   * Creates and returns a transaction for the intent. The transaction\n   * will execute the swap according to the specified mode (ExactIn/ExactOut).\n   *\n   * @param params - Intent submission parameters\n   * @param params.inputMint - The mint address of the token to sell\n   * @param params.outputMint - The mint address of the token to buy\n   * @param params.amount - The exact amount (input or output based on mode)\n   * @param params.mode - 'ExactIn' or 'ExactOut'\n   * @param params.slippageBps - Slippage tolerance in basis points\n   * @param params.userPublicKey - The user's Solana wallet public key\n   * @param params.priorityFee - Optional priority fee configuration\n   * @returns Intent response with transaction to sign\n   *\n   * @example\n   * ```typescript\n   * const intent = await dflow.intent.submitIntent({\n   *   inputMint: USDC_MINT,\n   *   outputMint: market.accounts.usdc.yesMint,\n   *   amount: 1000000,\n   *   mode: 'ExactIn',\n   *   slippageBps: 50,\n   *   userPublicKey: wallet.publicKey.toBase58(),\n   * });\n   *\n   * // Sign and send the transaction\n   * const result = await signSendAndConfirm(connection, intent.transaction, keypair);\n   * ```\n   */\n  async submitIntent(params: SubmitIntentParams): Promise<IntentResponse> {\n    // First get a quote\n    const quoteResponse = await this.getIntentQuote({\n      inputMint: params.inputMint,\n      outputMint: params.outputMint,\n      amount: params.amount,\n      mode: params.mode,\n    });\n\n    // Then submit intent with the quote response\n    return this.http.post<IntentResponse>('/submit-intent', {\n      quoteResponse,\n      userPublicKey: params.userPublicKey,\n      slippageBps: params.slippageBps,\n      priorityFee: params.priorityFee,\n    });\n  }\n}\n","import type { HttpClient } from '../../utils/http.js';\nimport type {\n  PredictionMarketInitParams,\n  PredictionMarketInitResponse,\n} from '../../types/index.js';\nimport { USDC_MINT } from '../../utils/constants.js';\n\n/**\n * API for initializing new prediction markets.\n *\n * Create new prediction markets on-chain. This initializes the market\n * accounts and creates YES/NO outcome token mints.\n *\n * @example\n * ```typescript\n * const dflow = new DFlowClient({ environment: 'production', apiKey: 'your-key' });\n *\n * const init = await dflow.predictionMarket.initializeMarket({\n *   marketTicker: 'MY-MARKET-TICKER',\n *   userPublicKey: wallet.publicKey.toBase58(),\n * });\n *\n * console.log(`YES mint: ${init.yesMint}`);\n * console.log(`NO mint: ${init.noMint}`);\n * // Sign and send init.transaction to create the market\n * ```\n */\nexport class PredictionMarketAPI {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Initialize a new prediction market.\n   *\n   * Creates a new prediction market with YES and NO outcome tokens.\n   * The returned transaction must be signed and sent to complete\n   * market creation.\n   *\n   * @param params - Market initialization parameters\n   * @param params.marketTicker - Unique ticker for the new market\n   * @param params.userPublicKey - The creator's Solana wallet public key\n   * @param params.settlementMint - Token mint for settlement (defaults to USDC)\n   * @returns Initialization response with transaction and mint addresses\n   *\n   * @example\n   * ```typescript\n   * import { USDC_MINT } from 'dflow-sdk';\n   *\n   * const init = await dflow.predictionMarket.initializeMarket({\n   *   marketTicker: 'BTCPRICE-25DEC-100K',\n   *   userPublicKey: wallet.publicKey.toBase58(),\n   *   settlementMint: USDC_MINT, // Optional, defaults to USDC\n   * });\n   *\n   * // Sign and send the initialization transaction\n   * const result = await signSendAndConfirm(connection, init.transaction, keypair);\n   *\n   * // Store the mint addresses for trading\n   * console.log(`Market created!`);\n   * console.log(`YES token: ${init.yesMint}`);\n   * console.log(`NO token: ${init.noMint}`);\n   * ```\n   */\n  async initializeMarket(params: PredictionMarketInitParams): Promise<PredictionMarketInitResponse> {\n    return this.http.get<PredictionMarketInitResponse>('/prediction-market-init', {\n      marketTicker: params.marketTicker,\n      userPublicKey: params.userPublicKey,\n      settlementMint: params.settlementMint ?? USDC_MINT,\n    });\n  }\n}\n","import type { HttpClient } from '../../utils/http.js';\nimport type { Token, TokenWithDecimals } from '../../types/index.js';\n\n/**\n * API for retrieving available token information.\n *\n * Get information about tokens supported for trading, including\n * their mint addresses and decimal precision.\n *\n * @example\n * ```typescript\n * const dflow = new DFlowClient();\n *\n * // Get all available tokens\n * const tokens = await dflow.tokens.getTokens();\n *\n * // Get tokens with decimal information\n * const tokensWithDecimals = await dflow.tokens.getTokensWithDecimals();\n * ```\n */\nexport class TokensAPI {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Get all available tokens for trading.\n   *\n   * @returns Array of token information\n   *\n   * @example\n   * ```typescript\n   * const tokens = await dflow.tokens.getTokens();\n   * tokens.forEach(token => {\n   *   console.log(`${token.symbol}: ${token.mint}`);\n   * });\n   * ```\n   */\n  async getTokens(): Promise<Token[]> {\n    return this.http.get<Token[]>('/tokens');\n  }\n\n  /**\n   * Get all available tokens with decimal information.\n   *\n   * Includes the number of decimal places for each token,\n   * useful for formatting amounts correctly.\n   *\n   * @returns Array of tokens with decimal information\n   *\n   * @example\n   * ```typescript\n   * const tokens = await dflow.tokens.getTokensWithDecimals();\n   * tokens.forEach(token => {\n   *   console.log(`${token.symbol}: ${token.decimals} decimals`);\n   *   // Convert 1 token to base units\n   *   const baseUnits = 1 * Math.pow(10, token.decimals);\n   * });\n   * ```\n   */\n  async getTokensWithDecimals(): Promise<TokenWithDecimals[]> {\n    return this.http.get<TokenWithDecimals[]>('/tokens-with-decimals');\n  }\n}\n","import type { HttpClient } from '../../utils/http.js';\nimport type { Venue } from '../../types/index.js';\n\n/**\n * API for retrieving trading venue information.\n *\n * Venues represent the underlying exchanges or liquidity sources\n * where trades are executed.\n *\n * @example\n * ```typescript\n * const dflow = new DFlowClient();\n *\n * const venues = await dflow.venues.getVenues();\n * venues.forEach(venue => console.log(venue.name));\n * ```\n */\nexport class VenuesAPI {\n  constructor(private http: HttpClient) {}\n\n  /**\n   * Get all available trading venues.\n   *\n   * @returns Array of venue information\n   *\n   * @example\n   * ```typescript\n   * const venues = await dflow.venues.getVenues();\n   * venues.forEach(venue => {\n   *   console.log(`${venue.name}: ${venue.description}`);\n   * });\n   * ```\n   */\n  async getVenues(): Promise<Venue[]> {\n    return this.http.get<Venue[]>('/venues');\n  }\n}\n","import type {\n  WebSocketOptions,\n  WebSocketChannel,\n  WebSocketMessage,\n  PriceUpdate,\n  TradeUpdate,\n  OrderbookUpdate,\n  WebSocketUpdate,\n} from '../types/index.js';\nimport { WEBSOCKET_URL } from '../utils/constants.js';\n\ntype MessageCallback<T> = (data: T) => void;\ntype ErrorCallback = (error: Error) => void;\ntype CloseCallback = (event: CloseEvent) => void;\n\n/**\n * WebSocket client for real-time price, trade, and orderbook updates.\n *\n * Provides streaming market data with automatic reconnection support.\n * Subscribe to specific markets or all markets for each data channel.\n *\n * @example\n * ```typescript\n * const dflow = new DFlowClient();\n *\n * // Connect to WebSocket\n * await dflow.ws.connect();\n *\n * // Subscribe to price updates for specific markets\n * dflow.ws.subscribePrices(['BTCD-25DEC0313-T92749.99']);\n *\n * // Handle price updates\n * const unsubscribe = dflow.ws.onPrice((update) => {\n *   console.log(`${update.ticker}: YES=${update.yesPrice} NO=${update.noPrice}`);\n * });\n *\n * // Later: cleanup\n * unsubscribe(); // Remove callback\n * dflow.ws.disconnect(); // Close connection\n * ```\n */\nexport class DFlowWebSocket {\n  private ws: WebSocket | null = null;\n  private url: string;\n  private reconnect: boolean;\n  private reconnectInterval: number;\n  private maxReconnectAttempts: number;\n  private reconnectAttempts = 0;\n  private isConnecting = false;\n\n  private priceCallbacks: MessageCallback<PriceUpdate>[] = [];\n  private tradeCallbacks: MessageCallback<TradeUpdate>[] = [];\n  private orderbookCallbacks: MessageCallback<OrderbookUpdate>[] = [];\n  private errorCallbacks: ErrorCallback[] = [];\n  private closeCallbacks: CloseCallback[] = [];\n\n  /**\n   * Create a new WebSocket client.\n   *\n   * @param options - WebSocket configuration options\n   * @param options.url - Custom WebSocket URL (defaults to DFlow WebSocket)\n   * @param options.reconnect - Whether to auto-reconnect on disconnect (default: true)\n   * @param options.reconnectInterval - Milliseconds between reconnect attempts (default: 5000)\n   * @param options.maxReconnectAttempts - Max reconnection attempts (default: 10)\n   */\n  constructor(options?: WebSocketOptions) {\n    this.url = options?.url ?? WEBSOCKET_URL;\n    this.reconnect = options?.reconnect ?? true;\n    this.reconnectInterval = options?.reconnectInterval ?? 5000;\n    this.maxReconnectAttempts = options?.maxReconnectAttempts ?? 10;\n  }\n\n  /**\n   * Connect to the WebSocket server.\n   *\n   * Must be called before subscribing to any channels.\n   * Resolves when connection is established.\n   *\n   * @returns Promise that resolves when connected\n   * @throws Error if connection fails\n   *\n   * @example\n   * ```typescript\n   * await dflow.ws.connect();\n   * console.log('Connected!', dflow.ws.isConnected);\n   * ```\n   */\n  async connect(): Promise<void> {\n    if (this.ws?.readyState === WebSocket.OPEN) {\n      return;\n    }\n\n    if (this.isConnecting) {\n      return;\n    }\n\n    this.isConnecting = true;\n\n    return new Promise((resolve, reject) => {\n      try {\n        this.ws = new WebSocket(this.url);\n\n        this.ws.onopen = () => {\n          this.isConnecting = false;\n          this.reconnectAttempts = 0;\n          resolve();\n        };\n\n        this.ws.onmessage = (event) => {\n          this.handleMessage(event);\n        };\n\n        this.ws.onerror = () => {\n          this.isConnecting = false;\n          const error = new Error('WebSocket error');\n          this.errorCallbacks.forEach((cb) => cb(error));\n          reject(error);\n        };\n\n        this.ws.onclose = (event) => {\n          this.isConnecting = false;\n          this.closeCallbacks.forEach((cb) => cb(event));\n          this.attemptReconnect();\n        };\n      } catch (error) {\n        this.isConnecting = false;\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Disconnect from the WebSocket server.\n   *\n   * Disables auto-reconnect and closes the connection.\n   *\n   * @example\n   * ```typescript\n   * dflow.ws.disconnect();\n   * ```\n   */\n  disconnect(): void {\n    this.reconnect = false;\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n\n  private attemptReconnect(): void {\n    if (!this.reconnect) return;\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      const error = new Error('Max reconnection attempts reached');\n      this.errorCallbacks.forEach((cb) => cb(error));\n      return;\n    }\n\n    this.reconnectAttempts++;\n    setTimeout(() => {\n      this.connect().catch(() => {\n        // Reconnection failed, will retry\n      });\n    }, this.reconnectInterval);\n  }\n\n  private handleMessage(event: MessageEvent): void {\n    try {\n      const data = JSON.parse(event.data) as WebSocketUpdate;\n\n      switch (data.channel) {\n        case 'prices':\n          this.priceCallbacks.forEach((cb) => cb(data as PriceUpdate));\n          break;\n        case 'trades':\n          this.tradeCallbacks.forEach((cb) => cb(data as TradeUpdate));\n          break;\n        case 'orderbook':\n          this.orderbookCallbacks.forEach((cb) => cb(data as OrderbookUpdate));\n          break;\n      }\n    } catch (error) {\n      const err = error instanceof Error ? error : new Error('Failed to parse message');\n      this.errorCallbacks.forEach((cb) => cb(err));\n    }\n  }\n\n  private send(message: WebSocketMessage): void {\n    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {\n      throw new Error('WebSocket is not connected');\n    }\n    this.ws.send(JSON.stringify(message));\n  }\n\n  /**\n   * Subscribe to price updates for specific markets.\n   *\n   * @param tickers - Array of market tickers to subscribe to\n   * @throws Error if WebSocket is not connected\n   *\n   * @example\n   * ```typescript\n   * dflow.ws.subscribePrices(['BTCD-25DEC0313-T92749.99', 'ETHD-25DEC0313']);\n   * ```\n   */\n  subscribePrices(tickers: string[]): void {\n    this.send({ type: 'subscribe', channel: 'prices', tickers });\n  }\n\n  /**\n   * Subscribe to price updates for all markets.\n   *\n   * @throws Error if WebSocket is not connected\n   *\n   * @example\n   * ```typescript\n   * dflow.ws.subscribeAllPrices();\n   * ```\n   */\n  subscribeAllPrices(): void {\n    this.send({ type: 'subscribe', channel: 'prices', all: true });\n  }\n\n  /**\n   * Subscribe to trade updates for specific markets.\n   *\n   * @param tickers - Array of market tickers to subscribe to\n   * @throws Error if WebSocket is not connected\n   *\n   * @example\n   * ```typescript\n   * dflow.ws.subscribeTrades(['BTCD-25DEC0313-T92749.99']);\n   * ```\n   */\n  subscribeTrades(tickers: string[]): void {\n    this.send({ type: 'subscribe', channel: 'trades', tickers });\n  }\n\n  /**\n   * Subscribe to trade updates for all markets.\n   *\n   * @throws Error if WebSocket is not connected\n   *\n   * @example\n   * ```typescript\n   * dflow.ws.subscribeAllTrades();\n   * ```\n   */\n  subscribeAllTrades(): void {\n    this.send({ type: 'subscribe', channel: 'trades', all: true });\n  }\n\n  /**\n   * Subscribe to orderbook updates for specific markets.\n   *\n   * @param tickers - Array of market tickers to subscribe to\n   * @throws Error if WebSocket is not connected\n   *\n   * @example\n   * ```typescript\n   * dflow.ws.subscribeOrderbook(['BTCD-25DEC0313-T92749.99']);\n   * ```\n   */\n  subscribeOrderbook(tickers: string[]): void {\n    this.send({ type: 'subscribe', channel: 'orderbook', tickers });\n  }\n\n  /**\n   * Subscribe to orderbook updates for all markets.\n   *\n   * @throws Error if WebSocket is not connected\n   *\n   * @example\n   * ```typescript\n   * dflow.ws.subscribeAllOrderbook();\n   * ```\n   */\n  subscribeAllOrderbook(): void {\n    this.send({ type: 'subscribe', channel: 'orderbook', all: true });\n  }\n\n  /**\n   * Unsubscribe from a channel.\n   *\n   * @param channel - The channel to unsubscribe from ('prices', 'trades', or 'orderbook')\n   * @param tickers - Optional specific tickers to unsubscribe. If omitted, unsubscribes from all.\n   * @throws Error if WebSocket is not connected\n   *\n   * @example\n   * ```typescript\n   * // Unsubscribe from specific markets\n   * dflow.ws.unsubscribe('prices', ['BTCD-25DEC0313-T92749.99']);\n   *\n   * // Unsubscribe from all on a channel\n   * dflow.ws.unsubscribe('trades');\n   * ```\n   */\n  unsubscribe(channel: WebSocketChannel, tickers?: string[]): void {\n    if (tickers) {\n      this.send({ type: 'unsubscribe', channel, tickers });\n    } else {\n      this.send({ type: 'unsubscribe', channel, all: true });\n    }\n  }\n\n  /**\n   * Register a callback for price updates.\n   *\n   * @param callback - Function called when a price update is received\n   * @returns Unsubscribe function to remove the callback\n   *\n   * @example\n   * ```typescript\n   * const unsubscribe = dflow.ws.onPrice((update) => {\n   *   console.log(`${update.ticker}: YES=${update.yesPrice} NO=${update.noPrice}`);\n   * });\n   *\n   * // Later: remove callback\n   * unsubscribe();\n   * ```\n   */\n  onPrice(callback: MessageCallback<PriceUpdate>): () => void {\n    this.priceCallbacks.push(callback);\n    return () => {\n      this.priceCallbacks = this.priceCallbacks.filter((cb) => cb !== callback);\n    };\n  }\n\n  /**\n   * Register a callback for trade updates.\n   *\n   * @param callback - Function called when a trade update is received\n   * @returns Unsubscribe function to remove the callback\n   *\n   * @example\n   * ```typescript\n   * const unsubscribe = dflow.ws.onTrade((trade) => {\n   *   console.log(`Trade: ${trade.side} ${trade.amount} @ ${trade.price}`);\n   * });\n   *\n   * // Later: remove callback\n   * unsubscribe();\n   * ```\n   */\n  onTrade(callback: MessageCallback<TradeUpdate>): () => void {\n    this.tradeCallbacks.push(callback);\n    return () => {\n      this.tradeCallbacks = this.tradeCallbacks.filter((cb) => cb !== callback);\n    };\n  }\n\n  /**\n   * Register a callback for orderbook updates.\n   *\n   * @param callback - Function called when an orderbook update is received\n   * @returns Unsubscribe function to remove the callback\n   *\n   * @example\n   * ```typescript\n   * const unsubscribe = dflow.ws.onOrderbook((book) => {\n   *   console.log(`${book.ticker}: Bid=${book.yesBid} Ask=${book.yesAsk}`);\n   * });\n   *\n   * // Later: remove callback\n   * unsubscribe();\n   * ```\n   */\n  onOrderbook(callback: MessageCallback<OrderbookUpdate>): () => void {\n    this.orderbookCallbacks.push(callback);\n    return () => {\n      this.orderbookCallbacks = this.orderbookCallbacks.filter((cb) => cb !== callback);\n    };\n  }\n\n  /**\n   * Register a callback for WebSocket errors.\n   *\n   * @param callback - Function called when an error occurs\n   * @returns Unsubscribe function to remove the callback\n   *\n   * @example\n   * ```typescript\n   * const unsubscribe = dflow.ws.onError((error) => {\n   *   console.error('WebSocket error:', error.message);\n   * });\n   * ```\n   */\n  onError(callback: ErrorCallback): () => void {\n    this.errorCallbacks.push(callback);\n    return () => {\n      this.errorCallbacks = this.errorCallbacks.filter((cb) => cb !== callback);\n    };\n  }\n\n  /**\n   * Register a callback for WebSocket close events.\n   *\n   * @param callback - Function called when the connection closes\n   * @returns Unsubscribe function to remove the callback\n   *\n   * @example\n   * ```typescript\n   * const unsubscribe = dflow.ws.onClose((event) => {\n   *   console.log('WebSocket closed:', event.code, event.reason);\n   * });\n   * ```\n   */\n  onClose(callback: CloseCallback): () => void {\n    this.closeCallbacks.push(callback);\n    return () => {\n      this.closeCallbacks = this.closeCallbacks.filter((cb) => cb !== callback);\n    };\n  }\n\n  /**\n   * Check if the WebSocket is currently connected.\n   *\n   * @returns true if connected, false otherwise\n   *\n   * @example\n   * ```typescript\n   * if (dflow.ws.isConnected) {\n   *   dflow.ws.subscribePrices(['BTCD-25DEC0313-T92749.99']);\n   * }\n   * ```\n   */\n  get isConnected(): boolean {\n    return this.ws?.readyState === WebSocket.OPEN;\n  }\n}\n","import { HttpClient } from './utils/http.js';\nimport {\n  METADATA_API_BASE_URL,\n  TRADE_API_BASE_URL,\n  PROD_METADATA_API_BASE_URL,\n  PROD_TRADE_API_BASE_URL,\n  WEBSOCKET_URL,\n  PROD_WEBSOCKET_URL,\n} from './utils/constants.js';\n\nimport {\n  EventsAPI,\n  MarketsAPI,\n  OrderbookAPI,\n  TradesAPI,\n  LiveDataAPI,\n  SeriesAPI,\n  TagsAPI,\n  SportsAPI,\n  SearchAPI,\n} from './api/metadata/index.js';\n\nimport {\n  OrdersAPI,\n  SwapAPI,\n  IntentAPI,\n  PredictionMarketAPI,\n  TokensAPI,\n  VenuesAPI,\n} from './api/trade/index.js';\n\nimport { DFlowWebSocket } from './websocket/client.js';\n\nimport type { WebSocketOptions } from './types/index.js';\n\n/**\n * Environment type for DFlow API endpoints.\n * - 'development': Uses dev endpoints, no API key required. Good for testing with real capital against Kalshi.\n * - 'production': Uses prod endpoints, API key required. For production deployments.\n */\nexport type DFlowEnvironment = 'development' | 'production';\n\n/**\n * Configuration options for the DFlow client.\n */\nexport interface DFlowClientOptions {\n  /**\n   * Environment to use. Defaults to 'development'.\n   * - 'development': No API key required, uses dev-*.dflow.net endpoints\n   * - 'production': API key required, uses *.dflow.net endpoints\n   */\n  environment?: DFlowEnvironment;\n  /** API key for authenticated endpoints (required for production) */\n  apiKey?: string;\n  /** Custom base URL for the metadata API (overrides environment setting) */\n  metadataBaseUrl?: string;\n  /** Custom base URL for the trade API (overrides environment setting) */\n  tradeBaseUrl?: string;\n  /** WebSocket connection options */\n  wsOptions?: WebSocketOptions;\n}\n\n/**\n * Main client for interacting with the DFlow prediction markets platform.\n *\n * @example\n * ```typescript\n * import { DFlowClient } from 'dflow-sdk';\n *\n * // Development (default) - no API key required\n * // Uses dev-*.dflow.net endpoints for testing with real capital\n * const dflow = new DFlowClient();\n * const markets = await dflow.markets.getMarkets();\n *\n * // Production - API key required\n * // Uses *.dflow.net endpoints for production deployments\n * const dflow = new DFlowClient({\n *   environment: 'production',\n *   apiKey: 'your-api-key',\n * });\n *\n * // Get a quote and trade\n * const quote = await dflow.swap.getQuote({\n *   inputMint: USDC_MINT,\n *   outputMint: yesMint,\n *   amount: 1000000,\n * });\n * ```\n */\nexport class DFlowClient {\n  private metadataHttp: HttpClient;\n  private tradeHttp: HttpClient;\n\n  /** API for discovering and querying prediction events */\n  public readonly events: EventsAPI;\n  /** API for market data, pricing, and batch queries */\n  public readonly markets: MarketsAPI;\n  /** API for orderbook snapshots */\n  public readonly orderbook: OrderbookAPI;\n  /** API for historical trade data */\n  public readonly trades: TradesAPI;\n  /** API for real-time milestone data */\n  public readonly liveData: LiveDataAPI;\n  /** API for series/category information */\n  public readonly series: SeriesAPI;\n  /** API for tag-based filtering */\n  public readonly tags: TagsAPI;\n  /** API for sports-specific filters */\n  public readonly sports: SportsAPI;\n  /** API for searching events and markets */\n  public readonly search: SearchAPI;\n\n  /** API for order creation and status (requires API key) */\n  public readonly orders: OrdersAPI;\n  /** API for imperative swaps with route preview (requires API key) */\n  public readonly swap: SwapAPI;\n  /** API for declarative intent-based swaps (requires API key) */\n  public readonly intent: IntentAPI;\n  /** API for prediction market initialization (requires API key) */\n  public readonly predictionMarket: PredictionMarketAPI;\n  /** API for token information */\n  public readonly tokens: TokensAPI;\n  /** API for trading venue information */\n  public readonly venues: VenuesAPI;\n\n  /** WebSocket client for real-time price, trade, and orderbook updates */\n  public readonly ws: DFlowWebSocket;\n\n  /**\n   * Create a new DFlow client instance.\n   *\n   * @param options - Client configuration options\n   */\n  constructor(options?: DFlowClientOptions) {\n    const env = options?.environment ?? 'development';\n    const isProd = env === 'production';\n\n    // Determine URLs based on environment (custom URLs override environment)\n    const metadataUrl = options?.metadataBaseUrl ?? (isProd ? PROD_METADATA_API_BASE_URL : METADATA_API_BASE_URL);\n    const tradeUrl = options?.tradeBaseUrl ?? (isProd ? PROD_TRADE_API_BASE_URL : TRADE_API_BASE_URL);\n    const wsUrl = isProd ? PROD_WEBSOCKET_URL : WEBSOCKET_URL;\n\n    this.metadataHttp = new HttpClient({\n      baseUrl: metadataUrl,\n      apiKey: options?.apiKey,\n    });\n\n    this.tradeHttp = new HttpClient({\n      baseUrl: tradeUrl,\n      apiKey: options?.apiKey,\n    });\n\n    this.events = new EventsAPI(this.metadataHttp);\n    this.markets = new MarketsAPI(this.metadataHttp);\n    this.orderbook = new OrderbookAPI(this.metadataHttp);\n    this.trades = new TradesAPI(this.metadataHttp);\n    this.liveData = new LiveDataAPI(this.metadataHttp);\n    this.series = new SeriesAPI(this.metadataHttp);\n    this.tags = new TagsAPI(this.metadataHttp);\n    this.sports = new SportsAPI(this.metadataHttp);\n    this.search = new SearchAPI(this.metadataHttp);\n\n    this.orders = new OrdersAPI(this.tradeHttp);\n    this.swap = new SwapAPI(this.tradeHttp);\n    this.intent = new IntentAPI(this.tradeHttp);\n    this.predictionMarket = new PredictionMarketAPI(this.tradeHttp);\n    this.tokens = new TokensAPI(this.tradeHttp);\n    this.venues = new VenuesAPI(this.tradeHttp);\n\n    this.ws = new DFlowWebSocket({ ...options?.wsOptions, url: options?.wsOptions?.url ?? wsUrl });\n  }\n\n  /**\n   * Update the API key for both metadata and trade HTTP clients.\n   * Useful for setting the key after initialization or rotating keys.\n   *\n   * @param apiKey - The new API key to use\n   *\n   * @example\n   * ```typescript\n   * const dflow = new DFlowClient();\n   *\n   * // Browse markets without auth\n   * const markets = await dflow.markets.getMarkets();\n   *\n   * // Set API key when user logs in\n   * dflow.setApiKey('user-api-key');\n   *\n   * // Now can use authenticated endpoints\n   * const quote = await dflow.swap.getQuote(params);\n   * ```\n   */\n  setApiKey(apiKey: string): void {\n    this.metadataHttp.setApiKey(apiKey);\n    this.tradeHttp.setApiKey(apiKey);\n  }\n}\n","import {\n  Connection,\n  VersionedTransaction,\n  Keypair,\n  type Commitment,\n  type SignatureStatus,\n} from '@solana/web3.js';\nimport type { TransactionConfirmation } from '../types/index.js';\n\n/**\n * Sign and send a base64-encoded transaction to the Solana network.\n *\n * Deserializes the transaction, signs it with the provided keypair,\n * and sends it to the network.\n *\n * @param connection - Solana RPC connection\n * @param transactionBase64 - Base64-encoded transaction (from DFlow API responses)\n * @param signer - Keypair to sign the transaction with\n * @returns Transaction signature\n *\n * @example\n * ```typescript\n * import { Connection, Keypair } from '@solana/web3.js';\n * import { signAndSendTransaction } from 'dflow-sdk';\n *\n * const connection = new Connection('https://api.mainnet-beta.solana.com');\n * const keypair = Keypair.fromSecretKey(secretKey);\n *\n * const order = await dflow.orders.getOrder({ ... });\n * const signature = await signAndSendTransaction(connection, order.transaction, keypair);\n * console.log(`Transaction sent: ${signature}`);\n * ```\n */\nexport async function signAndSendTransaction(\n  connection: Connection,\n  transactionBase64: string,\n  signer: Keypair\n): Promise<string> {\n  const transactionBuffer = Buffer.from(transactionBase64, 'base64');\n  const transaction = VersionedTransaction.deserialize(transactionBuffer);\n\n  transaction.sign([signer]);\n\n  const signature = await connection.sendTransaction(transaction, {\n    skipPreflight: false,\n    preflightCommitment: 'confirmed',\n  });\n\n  return signature;\n}\n\n/**\n * Wait for a transaction to be confirmed on-chain.\n *\n * Polls the network until the transaction reaches the desired confirmation\n * level or times out.\n *\n * @param connection - Solana RPC connection\n * @param signature - Transaction signature to wait for\n * @param commitment - Desired confirmation level (default: 'confirmed')\n * @param timeoutMs - Maximum time to wait in milliseconds (default: 60000)\n * @returns Confirmation details including slot and status\n * @throws Error if transaction fails or times out\n *\n * @example\n * ```typescript\n * import { waitForConfirmation } from 'dflow-sdk';\n *\n * const confirmation = await waitForConfirmation(connection, signature, 'confirmed');\n * console.log(`Confirmed at slot ${confirmation.slot}`);\n * ```\n */\nexport async function waitForConfirmation(\n  connection: Connection,\n  signature: string,\n  commitment: Commitment = 'confirmed',\n  timeoutMs: number = 60000\n): Promise<TransactionConfirmation> {\n  const startTime = Date.now();\n\n  while (Date.now() - startTime < timeoutMs) {\n    const response = await connection.getSignatureStatus(signature);\n    const status: SignatureStatus | null = response.value;\n\n    if (status) {\n      if (status.err) {\n        throw new Error(`Transaction failed: ${JSON.stringify(status.err)}`);\n      }\n\n      const confirmationStatus = status.confirmationStatus;\n      if (\n        confirmationStatus === 'finalized' ||\n        (commitment === 'confirmed' && confirmationStatus === 'confirmed') ||\n        (commitment === 'processed' && confirmationStatus === 'processed')\n      ) {\n        return {\n          signature,\n          slot: status.slot,\n          confirmationStatus: confirmationStatus ?? 'processed',\n          err: status.err,\n        };\n      }\n    }\n\n    await sleep(2000);\n  }\n\n  throw new Error(`Transaction confirmation timeout after ${timeoutMs}ms`);\n}\n\n/**\n * Sign, send, and wait for confirmation in one call.\n *\n * Convenience function that combines {@link signAndSendTransaction} and\n * {@link waitForConfirmation} into a single operation.\n *\n * @param connection - Solana RPC connection\n * @param transactionBase64 - Base64-encoded transaction (from DFlow API responses)\n * @param signer - Keypair to sign the transaction with\n * @param commitment - Desired confirmation level (default: 'confirmed')\n * @returns Confirmation details including signature, slot, and status\n * @throws Error if transaction fails or times out\n *\n * @example\n * ```typescript\n * import { Connection, Keypair } from '@solana/web3.js';\n * import { DFlowClient, signSendAndConfirm, USDC_MINT } from 'dflow-sdk';\n *\n * const dflow = new DFlowClient();\n * const connection = new Connection('https://api.mainnet-beta.solana.com');\n * const keypair = Keypair.fromSecretKey(secretKey);\n *\n * // Get a swap transaction\n * const swap = await dflow.swap.createSwap({\n *   inputMint: USDC_MINT,\n *   outputMint: yesMint,\n *   amount: 1000000,\n *   slippageBps: 50,\n *   userPublicKey: keypair.publicKey.toBase58(),\n * });\n *\n * // Sign, send, and wait for confirmation\n * const result = await signSendAndConfirm(connection, swap.transaction, keypair);\n * console.log(`Transaction confirmed: ${result.signature}`);\n * console.log(`Slot: ${result.slot}`);\n * ```\n */\nexport async function signSendAndConfirm(\n  connection: Connection,\n  transactionBase64: string,\n  signer: Keypair,\n  commitment: Commitment = 'confirmed'\n): Promise<TransactionConfirmation> {\n  const signature = await signAndSendTransaction(connection, transactionBase64, signer);\n  return waitForConfirmation(connection, signature, commitment);\n}\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","import { Connection, PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID, TOKEN_2022_PROGRAM_ID } from '@solana/spl-token';\nimport type { TokenBalance, UserPosition, Market } from '../types/index.js';\nimport type { MarketsAPI } from '../api/metadata/markets.js';\n\n/**\n * Get all token balances for a wallet.\n *\n * Queries both the standard Token Program and Token-2022 Program to find\n * all token holdings. Returns only tokens with non-zero balances.\n *\n * @param connection - Solana RPC connection\n * @param walletAddress - Wallet public key to query\n * @returns Array of token balances with mint, balance, and decimal info\n *\n * @example\n * ```typescript\n * import { Connection, PublicKey } from '@solana/web3.js';\n * import { getTokenBalances } from 'dflow-sdk';\n *\n * const connection = new Connection('https://api.mainnet-beta.solana.com');\n * const wallet = new PublicKey('...');\n *\n * const balances = await getTokenBalances(connection, wallet);\n * balances.forEach(token => {\n *   console.log(`${token.mint}: ${token.balance} (${token.decimals} decimals)`);\n * });\n * ```\n */\nexport async function getTokenBalances(\n  connection: Connection,\n  walletAddress: PublicKey\n): Promise<TokenBalance[]> {\n  // Query both Token Program and Token-2022 Program\n  const [tokenAccounts, token2022Accounts] = await Promise.all([\n    connection.getParsedTokenAccountsByOwner(walletAddress, {\n      programId: TOKEN_PROGRAM_ID,\n    }),\n    connection.getParsedTokenAccountsByOwner(walletAddress, {\n      programId: TOKEN_2022_PROGRAM_ID,\n    }),\n  ]);\n\n  const allAccounts = [...tokenAccounts.value, ...token2022Accounts.value];\n\n  return allAccounts\n    .map(({ account }) => {\n      const info = account.data.parsed.info;\n      return {\n        mint: info.mint as string,\n        rawBalance: info.tokenAmount.amount as string,\n        balance: info.tokenAmount.uiAmount as number,\n        decimals: info.tokenAmount.decimals as number,\n      };\n    })\n    .filter((token) => token.balance > 0);\n}\n\n/**\n * Get a user's prediction market positions.\n *\n * Finds all prediction market outcome tokens in a wallet and enriches them\n * with market data and position type (YES/NO).\n *\n * @param connection - Solana RPC connection\n * @param walletAddress - Wallet public key to query\n * @param marketsAPI - Markets API instance for looking up market data\n * @returns Array of user positions with market context\n *\n * @example\n * ```typescript\n * import { Connection, PublicKey } from '@solana/web3.js';\n * import { DFlowClient, getUserPositions } from 'dflow-sdk';\n *\n * const dflow = new DFlowClient();\n * const connection = new Connection('https://api.mainnet-beta.solana.com');\n * const wallet = new PublicKey('...');\n *\n * const positions = await getUserPositions(connection, wallet, dflow.markets);\n *\n * positions.forEach(pos => {\n *   console.log(`${pos.position} position: ${pos.balance} tokens`);\n *   if (pos.market) {\n *     console.log(`  Market: ${pos.market.title}`);\n *     console.log(`  Status: ${pos.market.status}`);\n *   }\n * });\n * ```\n */\nexport async function getUserPositions(\n  connection: Connection,\n  walletAddress: PublicKey,\n  marketsAPI: MarketsAPI\n): Promise<UserPosition[]> {\n  const tokenBalances = await getTokenBalances(connection, walletAddress);\n\n  if (tokenBalances.length === 0) {\n    return [];\n  }\n\n  const allMints = tokenBalances.map((t) => t.mint);\n  const predictionMints = await marketsAPI.filterOutcomeMints(allMints);\n\n  if (predictionMints.length === 0) {\n    return [];\n  }\n\n  const outcomeTokens = tokenBalances.filter((t) => predictionMints.includes(t.mint));\n  const markets = await marketsAPI.getMarketsBatch({ mints: predictionMints });\n\n  const marketsByMint = new Map<string, Market>();\n  markets.forEach((market) => {\n    Object.values(market.accounts).forEach((account) => {\n      marketsByMint.set(account.yesMint, market);\n      marketsByMint.set(account.noMint, market);\n      marketsByMint.set(account.marketLedger, market);\n    });\n  });\n\n  return outcomeTokens.map((token) => {\n    const market = marketsByMint.get(token.mint) ?? null;\n\n    if (!market) {\n      return {\n        mint: token.mint,\n        balance: token.balance,\n        decimals: token.decimals,\n        position: 'UNKNOWN' as const,\n        market: null,\n      };\n    }\n\n    const isYesToken = Object.values(market.accounts).some(\n      (account) => account.yesMint === token.mint\n    );\n\n    const isNoToken = Object.values(market.accounts).some(\n      (account) => account.noMint === token.mint\n    );\n\n    return {\n      mint: token.mint,\n      balance: token.balance,\n      decimals: token.decimals,\n      position: isYesToken ? 'YES' : isNoToken ? 'NO' : 'UNKNOWN',\n      market,\n    };\n  });\n}\n\n/**\n * Check if a position is eligible for redemption.\n *\n * A position is eligible if:\n * - The market is 'determined' or 'finalized'\n * - The redemption window is open\n * - The position is on the winning side (or it's a scalar market)\n *\n * @param market - The market data\n * @param outcomeMint - The mint address of the outcome token to check\n * @returns true if the position can be redeemed\n *\n * @example\n * ```typescript\n * import { isRedemptionEligible } from 'dflow-sdk';\n *\n * const positions = await getUserPositions(connection, wallet, dflow.markets);\n *\n * for (const pos of positions) {\n *   if (pos.market && isRedemptionEligible(pos.market, pos.mint)) {\n *     console.log(`Position ${pos.mint} is redeemable!`);\n *   }\n * }\n * ```\n */\nexport function isRedemptionEligible(market: Market, outcomeMint: string): boolean {\n  if (market.status !== 'determined' && market.status !== 'finalized') {\n    return false;\n  }\n\n  for (const account of Object.values(market.accounts)) {\n    if (account.redemptionStatus !== 'open') {\n      continue;\n    }\n\n    const isWinningYes = market.result === 'yes' && account.yesMint === outcomeMint;\n    const isWinningNo = market.result === 'no' && account.noMint === outcomeMint;\n    const isScalarOutcome =\n      market.result === '' &&\n      account.scalarOutcomePct !== undefined &&\n      (account.yesMint === outcomeMint || account.noMint === outcomeMint);\n\n    if (isWinningYes || isWinningNo || isScalarOutcome) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Calculate the payout for a scalar market position.\n *\n * Scalar markets pay out based on where the outcome falls within a range.\n * YES tokens pay the outcome percentage, NO tokens pay the inverse.\n *\n * @param market - The market data\n * @param outcomeMint - The mint address of the outcome token\n * @param amount - The number of tokens held\n * @returns The payout amount in settlement tokens\n *\n * @example\n * ```typescript\n * import { calculateScalarPayout, isRedemptionEligible } from 'dflow-sdk';\n *\n * for (const pos of positions) {\n *   if (pos.market && isRedemptionEligible(pos.market, pos.mint)) {\n *     const payout = calculateScalarPayout(pos.market, pos.mint, pos.balance);\n *     console.log(`Expected payout: ${payout} USDC`);\n *   }\n * }\n * ```\n */\nexport function calculateScalarPayout(\n  market: Market,\n  outcomeMint: string,\n  amount: number\n): number {\n  for (const account of Object.values(market.accounts)) {\n    if (account.scalarOutcomePct === undefined) continue;\n\n    if (account.yesMint === outcomeMint) {\n      return (amount * account.scalarOutcomePct) / 10000;\n    }\n\n    if (account.noMint === outcomeMint) {\n      return (amount * (10000 - account.scalarOutcomePct)) / 10000;\n    }\n  }\n\n  return 0;\n}\n","import { DFlowApiError } from './http.js';\n\nexport interface RetryOptions {\n  /** Maximum number of retry attempts (default: 3) */\n  maxRetries?: number;\n  /** Initial delay in milliseconds before first retry (default: 1000) */\n  initialDelayMs?: number;\n  /** Maximum delay in milliseconds between retries (default: 30000) */\n  maxDelayMs?: number;\n  /** Multiplier for exponential backoff (default: 2) */\n  backoffMultiplier?: number;\n  /** Function to determine if an error should trigger a retry */\n  shouldRetry?: (error: unknown, attempt: number) => boolean;\n}\n\n/**\n * Default retry condition: retry on network errors and rate limits (429)\n */\nexport function defaultShouldRetry(error: unknown, _attempt: number): boolean {\n  if (error instanceof DFlowApiError) {\n    // Retry on rate limit (429) or server errors (5xx)\n    return error.statusCode === 429 || error.statusCode >= 500;\n  }\n  // Retry on network errors\n  if (error instanceof TypeError && error.message.includes('fetch')) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Calculate delay with exponential backoff and jitter\n */\nfunction calculateDelay(\n  attempt: number,\n  initialDelayMs: number,\n  maxDelayMs: number,\n  backoffMultiplier: number\n): number {\n  const exponentialDelay = initialDelayMs * Math.pow(backoffMultiplier, attempt);\n  const delayWithCap = Math.min(exponentialDelay, maxDelayMs);\n  // Add jitter (0-25% of delay) to prevent thundering herd\n  const jitter = delayWithCap * Math.random() * 0.25;\n  return delayWithCap + jitter;\n}\n\n/**\n * Execute a function with automatic retry on failure using exponential backoff.\n *\n * @example\n * ```typescript\n * import { withRetry } from 'dflow-sdk';\n *\n * // Basic usage\n * const markets = await withRetry(() => dflow.markets.getMarkets());\n *\n * // With custom options\n * const events = await withRetry(\n *   () => dflow.events.getEvents({ limit: 100 }),\n *   { maxRetries: 5, initialDelayMs: 500 }\n * );\n *\n * // Custom retry condition\n * const quote = await withRetry(\n *   () => dflow.swap.getQuote(params),\n *   {\n *     shouldRetry: (error) => {\n *       if (error instanceof DFlowApiError) {\n *         return error.statusCode === 429; // Only retry rate limits\n *       }\n *       return false;\n *     }\n *   }\n * );\n * ```\n *\n * @param fn - The async function to execute\n * @param options - Retry configuration options\n * @returns The result of the function\n * @throws The last error if all retries are exhausted\n */\nexport async function withRetry<T>(\n  fn: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<T> {\n  const {\n    maxRetries = 3,\n    initialDelayMs = 1000,\n    maxDelayMs = 30000,\n    backoffMultiplier = 2,\n    shouldRetry = defaultShouldRetry,\n  } = options;\n\n  let lastError: unknown;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error;\n\n      // Check if we should retry\n      if (attempt < maxRetries && shouldRetry(error, attempt)) {\n        const delay = calculateDelay(attempt, initialDelayMs, maxDelayMs, backoffMultiplier);\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        continue;\n      }\n\n      // No more retries, throw the error\n      throw error;\n    }\n  }\n\n  // This should never be reached, but TypeScript needs it\n  throw lastError;\n}\n\n/**\n * Create a retryable version of an async function.\n *\n * @example\n * ```typescript\n * import { createRetryable } from 'dflow-sdk';\n *\n * const getMarketsWithRetry = createRetryable(\n *   (params) => dflow.markets.getMarkets(params),\n *   { maxRetries: 5 }\n * );\n *\n * const markets = await getMarketsWithRetry({ limit: 50 });\n * ```\n *\n * @param fn - The async function to wrap\n * @param options - Retry configuration options\n * @returns A wrapped function with automatic retry\n */\nexport function createRetryable<TArgs extends unknown[], TResult>(\n  fn: (...args: TArgs) => Promise<TResult>,\n  options: RetryOptions = {}\n): (...args: TArgs) => Promise<TResult> {\n  return (...args: TArgs) => withRetry(() => fn(...args), options);\n}\n","import type { PaginationParams } from '../types/common.js';\n\n/**\n * Generic paginated response type that works with various API responses.\n * Supports both `data` field and custom field names like `markets`, `events`, etc.\n */\nexport interface PaginatedResult<T> {\n  cursor?: string;\n  items: T[];\n}\n\nexport interface PaginateOptions<TResponse, TItem> {\n  /** Maximum number of items to fetch in total (default: unlimited) */\n  maxItems?: number;\n  /** Number of items per page (default: API default, usually 50) */\n  pageSize?: number;\n  /**\n   * Function to extract items array from response.\n   * Required because different APIs use different field names (markets, events, data, etc.)\n   */\n  getItems: (response: TResponse) => TItem[];\n  /** Function to extract cursor from response (default: response.cursor) */\n  getCursor?: (response: TResponse) => string | undefined;\n}\n\n/**\n * Create an async iterator that automatically paginates through all results.\n *\n * @example\n * ```typescript\n * import { paginate } from 'dflow-sdk';\n *\n * // Iterate through all markets\n * for await (const market of paginate(\n *   (params) => dflow.markets.getMarkets(params),\n *   { getItems: (r) => r.markets }\n * )) {\n *   console.log(market.ticker, market.yesPrice);\n * }\n *\n * // Iterate through all events\n * for await (const event of paginate(\n *   (params) => dflow.events.getEvents({ ...params, status: 'active' }),\n *   { getItems: (r) => r.events, maxItems: 100 }\n * )) {\n *   console.log(event.title);\n * }\n * ```\n *\n * @param fetchPage - Function that fetches a page given pagination params\n * @param options - Pagination options including item extractor\n * @yields Individual items from each page\n */\nexport async function* paginate<TResponse extends { cursor?: string }, TItem>(\n  fetchPage: (params: PaginationParams) => Promise<TResponse>,\n  options: PaginateOptions<TResponse, TItem>\n): AsyncGenerator<TItem, void, undefined> {\n  const { maxItems, pageSize, getItems, getCursor = (r) => r.cursor } = options;\n\n  let cursor: string | undefined;\n  let itemsYielded = 0;\n\n  do {\n    const response = await fetchPage({\n      cursor,\n      limit: pageSize,\n    });\n\n    const items = getItems(response);\n    for (const item of items) {\n      yield item;\n      itemsYielded++;\n\n      if (maxItems !== undefined && itemsYielded >= maxItems) {\n        return;\n      }\n    }\n\n    cursor = getCursor(response);\n  } while (cursor);\n}\n\n/**\n * Collect all items from a paginated endpoint into an array.\n *\n * @example\n * ```typescript\n * import { collectAll } from 'dflow-sdk';\n *\n * // Get all markets as an array\n * const allMarkets = await collectAll(\n *   (params) => dflow.markets.getMarkets(params),\n *   { getItems: (r) => r.markets }\n * );\n *\n * console.log(`Found ${allMarkets.length} markets`);\n *\n * // With a limit\n * const first100 = await collectAll(\n *   (params) => dflow.events.getEvents(params),\n *   { getItems: (r) => r.events, maxItems: 100 }\n * );\n * ```\n *\n * @param fetchPage - Function that fetches a page given pagination params\n * @param options - Pagination options including item extractor\n * @returns Array of all items\n */\nexport async function collectAll<TResponse extends { cursor?: string }, TItem>(\n  fetchPage: (params: PaginationParams) => Promise<TResponse>,\n  options: PaginateOptions<TResponse, TItem>\n): Promise<TItem[]> {\n  const items: TItem[] = [];\n\n  for await (const item of paginate(fetchPage, options)) {\n    items.push(item);\n  }\n\n  return items;\n}\n\n/**\n * Count total items from a paginated endpoint without storing them.\n *\n * @example\n * ```typescript\n * import { countAll } from 'dflow-sdk';\n *\n * const totalMarkets = await countAll(\n *   (params) => dflow.markets.getMarkets(params),\n *   { getItems: (r) => r.markets }\n * );\n *\n * console.log(`Total markets: ${totalMarkets}`);\n * ```\n *\n * @param fetchPage - Function that fetches a page given pagination params\n * @param options - Pagination options including item extractor\n * @returns Total count of items\n */\nexport async function countAll<TResponse extends { cursor?: string }, TItem>(\n  fetchPage: (params: PaginationParams) => Promise<TResponse>,\n  options: PaginateOptions<TResponse, TItem>\n): Promise<number> {\n  let count = 0;\n\n  for await (const _ of paginate(fetchPage, options)) {\n    count++;\n  }\n\n  return count;\n}\n\n/**\n * Find the first item matching a predicate from a paginated endpoint.\n *\n * @example\n * ```typescript\n * import { findFirst } from 'dflow-sdk';\n *\n * // Find a specific market by title\n * const market = await findFirst(\n *   (params) => dflow.markets.getMarkets(params),\n *   { getItems: (r) => r.markets },\n *   (m) => m.title.includes('Bitcoin')\n * );\n *\n * if (market) {\n *   console.log('Found:', market.ticker);\n * }\n * ```\n *\n * @param fetchPage - Function that fetches a page given pagination params\n * @param options - Pagination options including item extractor\n * @param predicate - Function to test each item\n * @returns The first matching item, or undefined if not found\n */\nexport async function findFirst<TResponse extends { cursor?: string }, TItem>(\n  fetchPage: (params: PaginationParams) => Promise<TResponse>,\n  options: PaginateOptions<TResponse, TItem>,\n  predicate: (item: TItem) => boolean\n): Promise<TItem | undefined> {\n  for await (const item of paginate(fetchPage, options)) {\n    if (predicate(item)) {\n      return item;\n    }\n  }\n\n  return undefined;\n}\n"]}