---
title: Markets API
description: Fetch and query prediction markets
---

# Markets API

The Markets API provides methods to fetch and query prediction markets on DFlow.

## Access

```python
from dflow import DFlowClient

client = DFlowClient()
markets_api = client.markets
```

## Methods

### get_markets

Fetch multiple markets with optional filtering.

```python
def get_markets(
    status: MarketStatus | None = None,
    is_initialized: bool | None = None,
    sort: SortField | None = None,
    tickers: str | None = None,
    event_ticker: str | None = None,
    series_ticker: str | None = None,
    max_close_ts: int | None = None,
    min_close_ts: int | None = None,
    limit: int | None = None,
    cursor: int | None = None,
) -> MarketsResponse
```

#### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `status` | `str \| None` | Filter by status: `"active"`, `"closed"`, `"determined"`, `"finalized"` |
| `is_initialized` | `bool \| None` | Filter markets that are initialized |
| `sort` | `str \| None` | Sort field: `"volume"`, `"volume_24h"`, `"liquidity"`, `"open_interest"` |
| `tickers` | `str \| None` | Filter by specific market tickers (comma-separated) |
| `event_ticker` | `str \| None` | Filter by event ticker |
| `series_ticker` | `str \| None` | Filter by series ticker |
| `max_close_ts` | `int \| None` | Filter markets closing before this timestamp |
| `min_close_ts` | `int \| None` | Filter markets closing after this timestamp |
| `limit` | `int \| None` | Maximum number of markets to return |
| `cursor` | `int \| None` | Pagination cursor (number of markets to skip) |

#### Example

```python
# Get active markets sorted by volume
response = client.markets.get_markets(status="active", sort="volume")

for market in response.markets:
    print(f"{market.ticker}: YES={market.yes_ask}")

# Get initialized markets only
response = client.markets.get_markets(is_initialized=True)

# Paginate through results
if response.cursor:
    next_page = client.markets.get_markets(cursor=response.cursor)
```

### get_market

Fetch a single market by ticker.

```python
def get_market(market_id: str) -> Market
```

#### Example

```python
market = client.markets.get_market("BTCD-25DEC0313-T92749.99")
print(f"Status: {market.status}")
print(f"YES Ask: {market.yes_ask}")
```

### get_market_by_mint

Fetch a market by outcome token mint address.

```python
def get_market_by_mint(mint_address: str) -> Market
```

### get_markets_batch

Fetch multiple markets by tickers and/or mint addresses.

```python
def get_markets_batch(
    tickers: list[str] | None = None,
    mints: list[str] | None = None,
) -> list[Market]
```

#### Example

```python
markets = client.markets.get_markets_batch(
    tickers=["MARKET-1", "MARKET-2"],
    mints=["mint-address-1"],
)

for market in markets:
    print(f"{market.ticker}: {market.status}")
```

### get_outcome_mints

Get all outcome token mint addresses.

```python
def get_outcome_mints(min_close_ts: int | None = None) -> list[str]
```

#### Example

```python
# Get all outcome mints
all_mints = client.markets.get_outcome_mints()
print(f"Total outcome tokens: {len(all_mints)}")

# Get outcome mints for markets closing after a specific date
import time
future_mints = client.markets.get_outcome_mints(
    min_close_ts=int(time.time()),  # Only markets not yet closed
)
```

### filter_outcome_mints

Filter addresses to find outcome token mints.

```python
def filter_outcome_mints(addresses: list[str]) -> list[str]
```

### get_market_candlesticks

Get OHLCV candlestick data for a market.

```python
def get_market_candlesticks(
    ticker: str,
    params: CandlestickParams,
) -> list[Candlestick]
```

## Types

### Market

```python
class Market(BaseModel):
    ticker: str
    title: str
    subtitle: str
    event_ticker: str
    status: MarketStatus
    result: MarketResult
    market_type: str
    yes_sub_title: str
    no_sub_title: str
    can_close_early: bool
    rules_primary: str
    volume: float
    liquidity: float | None
    open_interest: float
    open_time: int
    close_time: int
    expiration_time: int
    accounts: dict[str, MarketAccount]
    yes_ask: str | None
    yes_bid: str | None
    no_ask: str | None
    no_bid: str | None
```

### MarketStatus

```python
MarketStatus = Literal[
    "initialized",
    "active",
    "inactive",
    "closed",
    "determined",
    "finalized",
]
```

### MarketsResponse

```python
class MarketsResponse(BaseModel):
    markets: list[Market]
    cursor: int | None
```
